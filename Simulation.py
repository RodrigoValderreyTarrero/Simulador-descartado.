"""
Author: Rodrigo Valderrey Tarrero

This code utilizes the infection trace generated by Epigraph and enables the user to set parameters for evaluating the quality of a vaccination strategy.
"""
import networkx as nx
import os
import re
import datetime
from collections import deque
import matplotlib.pyplot as plt

"""
Possible values for 'was_porter':
true
false
"""

"""
Possible values for 'state':
infected
vaccinated
saved
no-contact (same as susceptible)
"""

"""
Possible values for 'notified':
True (infected and notified)
False (infected and not notified)
None (not infected)
"""

"""
Possible values for 'written' (written in file):
True: written
False: not written
"""


class Contagion:
    def __init__(self, source, target, timestamp):
        self.source = source
        self.target = target
        self.timestamp = timestamp

class Simulation:
    def __init__(self, notification_delay, monthly_vaccination_capacity_percentage, contagion_filename, contacts_file, method_distance,show_curve):
        # parameters:
        self.method_distance = method_distance
        self.write_pagerank = False
        self.normalize_pr = True

        self.infections = []  # Array of Contagion objects.
        self.avoided_infections = 0
        self.today_vaccinated = set()
        self.G = nx.Graph()
        self.read_graph(contacts_file)
        self.fill_infections(contagion_filename)
        self.monthly_vaccination_capacity_percentage = monthly_vaccination_capacity_percentage
        self.daily_vaccines = round((monthly_vaccination_capacity_percentage * self.G.number_of_nodes() / 30.42))
        self.available_vaccines_today = self.daily_vaccines
        self.day = -1  # To assure that in the first iteration it starts with a zero (we start the simulation uppdating data)
        self.notification_day = self.day - notification_delay
        self.pending_infections = []
        self.vaccinated_count = 0

        #commonly needed
        self.pagerank_list, self.normalized_pr_list = self.extract_pagerank()
        # verbose
        self.infections_count = []

        self.show_curve = show_curve

    ### Correct.
    def extract_pagerank(self):
        # Calculate pr
        pagerank = nx.pagerank(self.G)
        for node, pr_value in pagerank.items():
            self.G.nodes[node]['PR'] = pr_value

        # Find the maximum pr to normalize
        max_pagerank = max(pagerank.values())
        # Normalize
        normalized_pagerank = {node: pr_value / max_pagerank for node, pr_value in pagerank.items()}

        # Sort nodes
        sorted_nodes_by_pagerank = sorted(pagerank.items(), key=lambda x: x[1], reverse=True)
        sorted_normalized_pagerank = sorted(normalized_pagerank.items(), key=lambda x: x[0], reverse=False)

        #By default is better not to write in a file the values of pagerank.
        if self.write_pagerank:
            with open("pagerank_valores_normalizados.txt", "w") as file:
                c = 0
                for i in range(128260):
                    if i not in self.G.nodes():
                        file.write(f"{0},")
                    else:
                        try:
                            if i == 128260 - 1:
                                file.write(f"{normalized_pagerank[c]}\n")
                            else:
                                file.write(f"{normalized_pagerank[c]},")
                        except:

                            file.write(f"{0},")
                        c += 1
        return sorted_nodes_by_pagerank, sorted_normalized_pagerank

    ### Correct.
    def update_data(self):
        """Funtion to restart the day"""
        self.available_vaccines_today = self.daily_vaccines
        self.day += 1
        self.notification_day += 1
        self.today_vaccinated = set()  # Restart

    ### Correct.
    def timestamp_a_dias(self, timestamp):
        """Transform Epigraph timestamps into corresponding calendar days"""
        inicio_epoch = datetime.datetime(2020, 1, 1)
        fecha_contagio = inicio_epoch + datetime.timedelta(minutes=timestamp)
        return (fecha_contagio - inicio_epoch).days

    # Correct.
    def register_daily_infections(self):
        #This data structure is a FIFO queue where each element represents a day. The queue's length is determined by the specified delay period.
        self.pending_infections.append(set())
        #For every new infection recorded on a given day, modify the corresponding state information.
        for i in self.infections[self.day]:
            if self.G.nodes[i.source].get('state') not in ["vaccinated", "saved"]:
                # 0 day infected
                self.G.nodes[i.source]['state'] = "infected"
                self.G.nodes[i.source]['was_porter'] = True
                self.pending_infections[-1].add(i.source)

            if self.check_infection(i):
                # if a new infection is detected (i.e., an unvaccinated or previously uninfected individual has been exposed), update the corresponding states.
                self.G.nodes[i.source]['was_porter'] = True
                self.G.nodes[i.target]['was_porter'] = True
                self.G.nodes[i.target]['state'] = 'infected'
                self.G.nodes[i.source]['state'] = 'infected'  # Maybe the source node was a 0 patient
                self.pending_infections[-1].add(i.source)
                self.pending_infections[-1].add(i.target)
            elif self.check_saved_target(i):
                self.avoided_infections += 1
                self.G.nodes[i.target]['state'] = 'saved'

    ## Correct.
    def register_daily_infections_with_notifications(self):
        """Record the infections as they occur, following the established delay."""
        dayly_infections_delay = self.pending_infections.pop(0)
        dayly_infections_delay = list(dayly_infections_delay)

        for node in dayly_infections_delay:
            self.G.nodes[node]['notified'] = True

    def check_saved_target(self, infection):
        """Returns if a target has been infected or not"""
        return (self.G.nodes[infection.source].get('state') in ["vaccinated", "saved"])

    ### Correct.
    def check_infection(self, infection):
        """Returns true if an infection has occurred at a specific moment."""
        return (self.G.nodes[infection.target].get('state') != "vaccinated" and
                self.G.nodes[infection.source].get('state') not in ["vaccinated", "saved"])

    ### Correct.
    def read_graph(self, directory_path):
        """Process each file in the directory. Needed to read the contact files"""
        for filename in os.listdir(directory_path):
            match = re.match(r"contacto_tipo_(\d+)\.txt", filename)
            if match:
                contact_type = match.group(1)  # Extract type from file name
                self.read_add_edges(os.path.join(directory_path, filename), contact_type)

    ###
    def read_add_edges(self, archivo, contact_type):
        """Read the contact files"""
        try:
            with open(archivo, 'r') as file:
                for line in file:
                    parts = line.strip().split()
                    src_node, dest_node = int(parts[0]), int(parts[1])
                    # Ensure that both nodes, src and dest, are in the graph with the initial attributes.
                    for node in (src_node, dest_node):
                        if not self.G.has_node(node):
                            self.G.add_node(node, state="no-contact", notified=False, written=False, was_porter=False)
                    self.G.add_edge(src_node, dest_node, tipo=contact_type, estado="")

        except IOError:
            print(f"Error: the file cannot get opened {archivo}")

    ###
    def fill_infections(self, archivo):
        """Function to fill the infections from the infected trace"""
        with open(archivo, 'r') as file:
            for line in file:
                parts = line.strip().split()
                src_node, dest_node, timestamp = int(parts[1]), int(parts[4]), int(parts[8])
                infection_day = self.timestamp_a_dias(timestamp)
                # If the list is not enough long
                while infection_day >= len(self.infections):
                    self.infections.append([])
                self.infections[infection_day].append(Contagion(src_node, dest_node, timestamp))

    ###
    def check_first_notification(self):
        """Checks if the first notification of an infeection has been registered"""
        return (len(self.infections[self.notification_day]) > 0)

    ###
    def check_first_infection(self):
        """Checks if the first notification of an infeection has been registered"""
        return (len(self.infections[self.day]) > 0)

    ###
    def write_results(self):
        with open(self.output_filename, 'a') as file:
            # Format: "day;value1,value2,value3,..."
            today_vaccinated = list(self.today_vaccinated)
            vaccinated_str = ','.join(str(v) for v in today_vaccinated)
            # Write the vaccinated nodes
            file.write(f"{self.day};{vaccinated_str}\n")

        # Actualizar el atributo 'written' de cada nodo procesado a True
        for node in today_vaccinated:
            if node in self.G:  # Verifica si el nodo realmente existe en el grafo
                self.G.nodes[node]['written'] = True  # Cambia el atributo a True
        if (len(today_vaccinated) != self.daily_vaccines):
            print("WARINING: vaccinated people (", len(today_vaccinated), ") is not equal to daily_vaccines (",self.daily_vaccines,")")
        self.vaccinated_count += len(today_vaccinated)

    ### BORRAR
    def restart_file(self):
        if os.path.exists(self.output_filename):
            os.remove(self.output_filename)

    ###

    def check_end(self):
        """Checks if all nodes are infected or vaccinated. If so, continuing the simulation is pointless as the final result will be the same."""
        return all(attr.get('state') in ('infected', 'vaccinated') for _, attr in self.G.nodes(data=True))


    def vaccine_if_corresponds(self, candidate):
        """Function that evaluates if someone is vaccinated. If so, it checks the vaccine's effectiveness"""
        if self.available_vaccines_today <= 0:
            return
        if candidate not in self.G:
            print("WARNING: trying to vaccinate : ", candidate, ", who is not in network.")
            return

        if (not self.G.nodes[candidate].get('notified')) and (
                self.G.nodes[candidate].get('state') != 'vaccinated') and (
        not self.G.nodes[candidate].get('written')):
            self.available_vaccines_today -= 1
            if self.G.nodes[candidate].get('state') != 'infected':
                # The vaccine is useful, if not, we have lose the dose anyway
                self.G.nodes[candidate]['state'] = 'vaccinated'
            self.today_vaccinated.add(candidate)
        else:
            #We don´t vaccinate and we keep the dose
            return


    ### Correct.
    def get_neighbors_at_exact_distance(self, node_id, exact_hops):
        """
        Retrieves neighbors of a node in a graph at an exact distance in terms of number of edge hops.
        If exact_hops is 0, the node itself is returned.
        """

        if node_id not in self.G:
            return []  # Devolver una lista vacía si el nodo no existe en el grafo

        visited = set()
        queue = deque([(node_id, 0)])  # Queue for BFS, storing pairs (node, current distance)
        neighbors_at_exact_distance = []

        if exact_hops == 0:
            neighbors_at_exact_distance.append(node_id)  # Include the node itself for exact_hops == 0

        while queue:
            current, dist = queue.popleft()

            if dist == exact_hops and current != node_id:  # Ensure the initial node is not added again
                neighbors_at_exact_distance.append(current)

            if dist < exact_hops:
                for neighbor in self.G.neighbors(current):
                    if neighbor not in visited:
                        visited.add(neighbor)
                        queue.append((neighbor, dist + 1))

        return neighbors_at_exact_distance

    ### Correct.
    def run_simulation(self):
        self.daily_infections_count = list()
        self.weekly_infections_count = list()
        current_day = 0


        for day in self.infections:
            #Update the daily data
            self.update_data()


            self.daily_infections_count.append(len(day))

            # calculate num infects if a week pass
            if len(self.daily_infections_count) % 7 == 0:
                self.weekly_infections_count.append(sum(self.daily_infections_count[-7:]))

            if not self.check_first_infection():
                continue
            self.register_daily_infections()

            if not self.check_first_notification():
                continue  # if first notification has not happened
            current_day += 1
            print("Current day in sumulation: ",current_day)
            # Register notifications
            self.register_daily_infections_with_notifications()
            #Here the policy is called.
            self.vaccinate()

            self.write_results()
            if self.check_end():
                # if this happens all nodes are infected or vaccinated
                print("\n\n\nThe simulation ended because all days were simulated.")
                print("Total vaccinations:", self.vaccinated_count)
                print("Total infections avoided:", self.avoided_infections)
                print("Infected people in each day:\n",
                      "".join(
                          f"Day:{day}: infected people {count}\n" for day, count in enumerate(self.infections_count)))
                return

            # register num nodes at the moment
            infected_count = sum(1 for node, attr in self.G.nodes(data=True) if attr.get('was_porter') == True)
            self.infections_count.append(infected_count)
        if self.show_curve:
            print("Showing infection data...")
            self.plot_infection_data()
            self.plot_infection_count()

        print("\n\n\nThe simulation ended because all days were simulated.")
        print("Total vaccinations:", self.vaccinated_count)
        print("Total infections avoided:", self.avoided_infections)
        print("Infected people in each day:\n",
              "".join(f"Day:{day}: infected people {count}\n" for day, count in enumerate(self.infections_count)))

    def plot_infection_data(self):
        plt.figure(figsize=(10, 5))
        plt.plot(self.daily_infections_count, label='Daily Infections')
        plt.xlabel('Days')
        plt.ylabel('Number of Infections')
        plt.title('Number of Infections per Day')
        plt.legend()
        plt.show()

        # plot weekly
        plt.figure(figsize=(10, 5))
        plt.plot(self.weekly_infections_count, label='Weekly Infections', color='orange')
        plt.xlabel('Weeks')
        plt.ylabel('Number of Infections')
        plt.title('Number of Infections per Week')
        plt.legend()
        plt.show()

    def plot_infection_count(self):
        #plot the number of infected nodes / day
        plt.figure(figsize=(10, 5))
        plt.plot(self.infections_count, label='Infected Nodes')
        plt.xlabel('Days')
        plt.ylabel('Number of Infected Nodes')
        plt.title('Number of Infected Nodes per Day')
        plt.legend()
        plt.show()
